<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-01-16 Tue 21:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Automata Theory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Lei Zhao" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link type="text/css" href="../../styles/syntax-highlight.css" rel="stylesheet"/>
<link type="text/css" href="../../styles/layout.css" rel="stylesheet"/>
<script type="text/javascript" src="../../src/post.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Automata Theory</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#finite-automata">1. <span class="done DONE">DONE</span> Finite Automata</a>
<ul>
<li><a href="#course-outline-and-motivation">1.1. <span class="done DONE">DONE</span> Course outline and motivation</a></li>
<li><a href="#informal-introduction-to-finite-automata">1.2. <span class="done DONE">DONE</span> Informal introduction to finite automata</a></li>
<li><a href="#deterministic-finite-automata">1.3. <span class="done DONE">DONE</span> Deterministic Finite Automata</a></li>
<li><a href="#nondeterministic-finite-automata">1.4. <span class="done DONE">DONE</span> Nondeterministic finite automata</a></li>
<li><a href="#finite-automata-homework">1.5. <span class="done DONE">DONE</span> Finite Automata Homework</a></li>
<li><a href="#challenge-problem-1">1.6. <span class="done DONE">DONE</span> Challenge Problem 1</a></li>
<li><a href="#orgc2f6769">1.7. <span class="done DONE">DONE</span> Problem Session 1</a></li>
</ul>
</li>
<li><a href="#regular-expressions-and-properties-of-regular-languages">2. <span class="todo IN_PROGRESS">IN-PROGRESS</span> Regular Expressions and Properties of Regular Languages</a>
<ul>
<li><a href="#regular-expressions">2.1. <span class="done DONE">DONE</span> Regular expressions</a></li>
<li><a href="#regular-expressions-in-the-real-world">2.2. <span class="done DONE">DONE</span> Regular expressions in the real world</a></li>
<li><a href="#regular-expression-homework">2.3. <span class="done DONE">DONE</span> Regular-Expression Homework</a></li>
<li><a href="#decision-algorithms-for-regular-languages">2.4. <span class="todo TODO">TODO</span> Decision algorithms for regular languages</a></li>
<li><a href="#closure-properties-of-regular-languages">2.5. <span class="todo TODO">TODO</span> Closure properties of regular languages</a></li>
<li><a href="#properties-of-regular-languages-homework">2.6. <span class="todo TODO">TODO</span> Properties-of-Regular-Languages Homework</a></li>
<li><a href="#challenge-problem-2">2.7. <span class="todo TODO">TODO</span> Challenge Problems 2</a></li>
<li><a href="#org82fe1c8">2.8. <span class="todo TODO">TODO</span> Problem Session 2</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+SelfPaced/courseware/751b6dfa045849d8bec2fdd55c89a3b9/">Automata Theory</a> on Lagunita
</p>

<div id="outline-container-org6f94018" class="outline-2">
<h2 id="finite-automata"><a id="org6f94018"></a><span class="section-number-2">1</span> <span class="done DONE">DONE</span> <a href="https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+SelfPaced/courseware/544b7a8df3844f428bc1a5125c594702/ec6439250bb4426ab93c543e140dacb4/">Finite Automata</a></h2>
<div class="outline-text-2" id="text-finite-automata">
</div>
<div id="outline-container-orgb8b6b88" class="outline-3">
<h3 id="course-outline-and-motivation"><a id="orgb8b6b88"></a><span class="section-number-3">1.1</span> <span class="done DONE">DONE</span> Course outline and motivation</h3>
<div class="outline-text-3" id="text-course-outline-and-motivation">
<p>
Automata is ranked second after database for optional courses in a
Stanford survey of grads 5 years out.  3X the score for AI.
</p>

<ul class="org-ul">
<li>Regular expressions are used in many systems.
<ul class="org-ul">
<li>UNIX a.*b.</li>
<li>DTD describe XML tags with a RE format like
<code>person(name, addr, child*)</code>.</li>
</ul></li>
<li>Finite automata model protocols, electronic circuits.</li>
<li>Context-free grammars are used to describe the syntax of
essentially every programming language.
<ul class="org-ul">
<li>Not to forget their important role in describing natural
languages.</li>
</ul></li>
<li>And DTD taken as a whole, are really CFGs.</li>
<li>When developing solutions to real problems, we often confront the
limitations of what software can do.
<ul class="org-ul">
<li><i>Undecidable</i> things - no program whatever can do it.</li>
<li><i>Intractable</i> things - there are programs, but no fast programs.</li>
</ul></li>
<li>Automata theory gives you the tools.</li>
</ul>

<p>
Other Good Stuff
</p>

<ul class="org-ul">
<li>We&rsquo;ll learn how to deal formally with discrete systems.
<ul class="org-ul">
<li>Proofs: You never really prove a program correct, but you need
to be thinking of why a tricky technique really works.</li>
</ul></li>
<li>We&rsquo;ll gain experience with abstract models and constructions.
<ul class="org-ul">
<li>Models layered software architectures.</li>
</ul></li>
</ul>

<p>
Course Outline
</p>

<ul class="org-ul">
<li>Regular Languages and their descriptors:
<ul class="org-ul">
<li>Finite automata, nondeterministic finite automata, regular
expressions.</li>
<li>Algorithms to decide questions about regular languages, e.g., is
it empty?</li>
<li>Closure properties of regular languages.</li>
</ul></li>
<li>Context-free languages and their descriptors:
<ul class="org-ul">
<li>Context-free grammars, pushdown automata.</li>
<li>Decision and closure properties.</li>
</ul></li>
<li>Recursive and recursively enumerable languages.
<ul class="org-ul">
<li>Turing machines, decidability of problems.</li>
<li>The limit of what can be computed.</li>
</ul></li>
<li>Intractable problems.
<ul class="org-ul">
<li>Problems that (appear to) require exponential time.</li>
<li>NP-completeness and beyond.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5328656" class="outline-3">
<h3 id="informal-introduction-to-finite-automata"><a id="org5328656"></a><span class="section-number-3">1.2</span> <span class="done DONE">DONE</span> Informal introduction to finite automata</h3>
<div class="outline-text-3" id="text-informal-introduction-to-finite-automata">
<p>
What is a Finite Automaton?
</p>

<ul class="org-ul">
<li>A formal system.</li>
<li>Remembers only a finite amount of information.</li>
<li>Information represented by its <i>state</i>.</li>
<li>State changes in response to <i>inputs</i>.</li>
<li>Rules that tell how the state changes in response to inputs are
called <i>transitions</i>.</li>
</ul>


<p>
Tennis
</p>

<ul class="org-ul">
<li><i>Match</i> = 3-5 sets.</li>
<li><i>Set</i> = 6 or more games.</li>
</ul>

<p>
Scoring a Game
</p>

<ul class="org-ul">
<li>One person serves throughout.</li>
<li>To win, you must score at least 4 points.</li>
<li>You also must win by at least 2 points.</li>
<li>Inputs are s = &ldquo;server wins point&rdquo; and o = &ldquo;opponent wins point.&rdquo;</li>
</ul>



<div class="figure">
<p><img src="tennis.png" alt="tennis.png" width="800px" />
</p>
<p><span class="figure-number">Figure 1: </span>The automaton for the game of tennis</p>
</div>


<p>
Acceptance of Inputs
</p>

<ul class="org-ul">
<li>Given a sequence of inputs (<i>input string</i>), start in the start
state and follow the transition from each symbol in turn.</li>
<li>Input is <i>accepted</i> if you wind up in a final (accepting) state
after all inputs have been read.</li>
</ul>

<p>
Language of an Automaton
</p>

<ul class="org-ul">
<li>The set of strings accepted by an automaton A is the <i>language</i> of A.</li>
<li>Denoted L(A).</li>
<li>Different sets of final states → different languages.</li>
<li>Example: As designed, L(Tennis) = strings that determines the winner.</li>
</ul>
</div>
</div>

<div id="outline-container-org01c4318" class="outline-3">
<h3 id="deterministic-finite-automata"><a id="org01c4318"></a><span class="section-number-3">1.3</span> <span class="done DONE">DONE</span> Deterministic Finite Automata</h3>
<div class="outline-text-3" id="text-deterministic-finite-automata">
<p>
Alphabets
</p>

<ul class="org-ul">
<li>An <i>alphabet</i> is any finite set of symbols.</li>
<li>Examples:
<ul class="org-ul">
<li>ASCII, Unicode,</li>
<li>{0, 1} (<i>binary alphabet</i>),</li>
<li>{a, b, c}, {s, o},</li>
<li>set of signals used by a protocol.</li>
</ul></li>
</ul>


<p>
Strings
</p>

<ul class="org-ul">
<li>A <i>string</i> over an alphabet Σ is a list, each element of
which is a member of Σ.
<ul class="org-ul">
<li>Strings shown with no commas or quotes, e.g., abc or 01101.</li>
</ul></li>
<li>Σ<sup>*</sup> = set of all strings over alphabet Σ.</li>
<li>The <i>length</i> of a string is its number of positions.</li>
<li>ε stands for the <i>empty string</i> (string of length 0).</li>
</ul>

<p>
Example: Strings
</p>

<ul class="org-ul">
<li>{0, 1}<sup>*</sup> = {ε, 0, 1, 00, 01, 10, 11, 000, 001, &#x2026;}</li>
<li>Subtlety: 0 as a string, 0 as a symbol look the same.
<ul class="org-ul">
<li>Context determines the type.</li>
</ul></li>
</ul>


<p>
Languages
</p>

<ul class="org-ul">
<li>A <i>language</i> is a subset of Σ<sup>*</sup> for some alphabet Σ.</li>
<li>Example: The set of string of 0s and 1s with no two consecutive 1s.</li>
<li>L = {ε, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000,
0001, 0010, 0100, 0101, 1000, 1001, 1010, &#x2026;}
<ul class="org-ul">
<li>Fibonacci sequence hides here.</li>
</ul></li>
</ul>


<p>
Deterministic Finite Automata
</p>

<ul class="org-ul">
<li>A formalism for defining languages,
consisting of:
<ol class="org-ol">
<li>A finite set of <i>states</i> (Q, typically).</li>
<li>An <i>input alphabet</i> (Σ, typically).</li>
<li>A <i>transition function</i> (δ, typically).</li>
<li>A <i>start state</i> (q<sub>0</sub>, in Q, typically).</li>
<li>A set of <i>final states</i> (F &sub; Q, typically).
<ul class="org-ul">
<li>&ldquo;Final&rdquo; and &ldquo;accepting&rdquo; are synonyms.</li>
</ul></li>
</ol></li>
</ul>


<p>
The Transition Function
</p>

<ul class="org-ul">
<li>Takes two arguments: a state and an input symbol.</li>
<li>δ(q, a) = the state that the DFA goes to when it is in state
q and input a is received.</li>
<li>Note: always a next state - add a <i>dead state</i> if no transition</li>
</ul>


<p>
Graph Representation of DFAs
</p>

<ul class="org-ul">
<li>Nodes = states.</li>
<li>Arcs represent transition function.
<ul class="org-ul">
<li>Arc from state p to state q labeled by all those input symbols
that have transitions from p to q.</li>
</ul></li>
<li>Arrow labeled &ldquo;Start&rdquo; to the start state.</li>
<li>Final states indicated by double circles.</li>
</ul>


<div class="figure">
<p><img src="ing.png" alt="ing.png" width="600px" />
</p>
<p><span class="figure-number">Figure 2: </span>Recognizing strings ending in &ldquo;ing&rdquo;</p>
</div>



<div class="figure">
<p><img src="send.png" alt="send.png" width="500px" />
</p>
<p><span class="figure-number">Figure 3: </span>Protocol for sending data</p>
</div>


<p>
A: String so far has no 11, does not end in 1.
B: String so far has no 11, but ends in a single 1.
C: Consecutive 1s have been seen.
</p>


<div id="orga2ad6ef" class="figure">
<p><img src="strings.png" alt="strings.png" width="500px" />
</p>
<p><span class="figure-number">Figure 4: </span>Strings without two consecutive 1s</p>
</div>


<p>
Alternative Representation: Transition Table
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">*</td>
<td class="org-left">A</td>
<td class="org-left">A</td>
<td class="org-left">B</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">B</td>
<td class="org-left">A</td>
<td class="org-left">C</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">C</td>
<td class="org-left">C</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>

<p>
Convention: Strings and Symbols
</p>
<ul class="org-ul">
<li>&#x2026; w, x, y, z are strings.</li>
<li>a, b, c, &#x2026; are single input symbols.</li>
</ul>

<p>
Extended Transition Function
</p>
<ul class="org-ul">
<li>We describe the effect of a string of inputs on a DFA by extending
δ to a state and a string.</li>
<li>Intuition: Extended δ is computed for state q and inputs
a<sub>1</sub>a<sub>2</sub>&#x2026;a<sub>n</sub> by following a path in the transition graph,
starting at q and selecting the arcs with labels a<sub>1</sub>, a<sub>2</sub>,
&#x2026;, a<sub>n</sub> in turn.</li>
</ul>

<p>
Inductive Definition of Extended δ
</p>
<ul class="org-ul">
<li>Induction on length of string.</li>
<li>Basis: δ(q, ε) = q</li>
<li>Induction: δ(q, wa) = δ(δ(q, w), a)
<ul class="org-ul">
<li>Remember: w is a string; a is an input symbol, by convention.</li>
</ul></li>
</ul>

<p>
Delta-hat
</p>
<ul class="org-ul">
<li>We don&rsquo;t distinguish between the given delta and the extended
delta or delta-hat.</li>
<li>The reason:
\(\hat\delta(q, a) = \delta(\hat\delta(q, \epsilon), a) = \delta(q, a)\)</li>
</ul>

<p>
Language of a DFA
</p>
<ul class="org-ul">
<li>Automata of all kinds define languages.</li>
<li>If A is an automaton, L(A) is its language.</li>
<li>For a DFA A, L(A) is the set of strings labeling paths from the
start state to a final state.</li>
<li>Formally: L(A) = the set of strings w such that δ(q<sub>0</sub>, w) is in F.</li>
</ul>

<p>
Example: String in a Language
</p>
<ul class="org-ul">
<li>String 101 is in the language of the string <a href="#orga2ad6ef">DFA</a>.</li>
<li>The language of this DFA is:
<ul class="org-ul">
<li>{w | w is in {0, 1}<sup>*</sup> and w does not have two consecutive 1s}</li>
</ul></li>
</ul>

<p>
Proofs of Set Equivalence
</p>
<ul class="org-ul">
<li>Often, we need to prove that two descriptions of sets are in fact
the same set</li>
<li>Here, one set is &ldquo;the language of this DFA,&rdquo; and the other is &ldquo;the
set of strings of 0s and 1s with no consecutive 1s.&rdquo;</li>
</ul>

<p>
Regular Languages
</p>
<ul class="org-ul">
<li>A language L is <i>regular</i> if it is the language accepted by some DFA.
<ul class="org-ul">
<li>Note: the DFA must accept only the strings in L, no others.</li>
</ul></li>
<li>Some languages are not regular.
<ul class="org-ul">
<li>Intuitively, regular languages &ldquo;cannot count&rdquo; to arbitrarily
high integers.</li>
</ul></li>
</ul>

<p>
Example: A Nonregular Language
</p>
<ul class="org-ul">
<li>L<sub>1</sub> = {0<sup>n</sup>1<sup>n</sup> | n ≥ 1}</li>
<li>Note: a<sup>i</sup> is conventional for i a&rsquo;s.
<ul class="org-ul">
<li>Thus, 0<sup>4</sup> = 0000, e.g.</li>
</ul></li>
<li>Read: The set of strings consisting of n 0s followed by n 1s,
such that n is at least 1.</li>
<li>Thus, L<sub>1</sub> = {01, 0011, 000111, &#x2026;}</li>
</ul>

<p>
Another Example
</p>
<ul class="org-ul">
<li>L<sub>2</sub> = {w | w in {(, )}<sup>*</sup> and w is <i>balanced</i>}</li>
<li>Balanced parentheses are those sequences of parentheses that can
appear in an arithmetic expression.</li>
<li>E.g., (), ()(), (()), (()()), &#x2026;</li>
</ul>

<p>
But Many Languages are Regular
</p>
<ul class="org-ul">
<li>They appear in many contexts and have many useful properties.</li>
<li>Example: the strings that represent floating point numbers in your
favorite language is a regular language.</li>
</ul>

<p>
Example: A Regular Language
</p>
<ul class="org-ul">
<li>L<sub>3</sub> = {w | w in {0, 1}<sup>*</sup> and w, viewed as a binary integer, is
divisible by 23}</li>
<li>The DFA:
<ul class="org-ul">
<li>23 states, named 0, 1, &#x2026;, 22.</li>
<li>Correspond to the 23 remainders of an integer divided by 23.</li>
<li>Start and only final state is 0.</li>
<li>If string w represents integer i, then assume δ(0, w) = i % 23.</li>
<li>Then w0 represents integer 2i, so we want δ(i%23, 0) = (2i) % 23.</li>
<li>Similarly, w1 represents 2i+1, so we want δ(i%23, 1) =
(2i+1) % 23.
<ul class="org-ul">
<li>Just let δ(q, a) = (2q+a) % 23.</li>
</ul></li>
<li>Example: δ(15, 0) = 30%23 = 7; δ(11, 1) = 23%23 = 0.</li>
</ul></li>
</ul>

<p>
Another Example
</p>
<ul class="org-ul">
<li>L<sub>4</sub> = {w | w in {0, 1}<sup>*</sup> and w, viewed as the reverse of a
binary integer, is divisible by 23}</li>
<li>Example: 01110100 is in L<sub>4</sub>, because its reverse, 00101110, is
46 in decimal.</li>
<li>Hard to construct the DFA.</li>
<li>But there is a theorem that says the reverse of a regular language
is also regular.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcf49889" class="outline-3">
<h3 id="nondeterministic-finite-automata"><a id="orgcf49889"></a><span class="section-number-3">1.4</span> <span class="done DONE">DONE</span> Nondeterministic finite automata</h3>
<div class="outline-text-3" id="text-nondeterministic-finite-automata">
<p>
Nondeterminism
</p>
<ul class="org-ul">
<li>A <i>nondeterministic finite automaton</i> has the ability to be in
several states at once.</li>
<li>Transitions from a state on an input symbol can be to any set of
states.</li>
<li>Start in one start state.</li>
<li>Accept if any sequence of choices lead to a final state.</li>
<li>Intuitively: the NFA always &ldquo;guesses right.&rdquo;</li>
</ul>

<p>
Example: Moves on a Chessboard
</p>
<ul class="org-ul">
<li>States = squares</li>
<li>Inputs = r (move to an adjacent red square) and b (move to an
adjacent black square).</li>
<li>Start state, final state are in opposite corners.</li>
</ul>


<div id="org5f94457" class="figure">
<p><img src="chess3x3.png" alt="chess3x3.png" width="300px" />
</p>
<p><span class="figure-number">Figure 5: </span>A 3×3 chessboard</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-left">r</th>
<th scope="col" class="org-left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-right">1</td>
<td class="org-left">2,4</td>
<td class="org-left">5</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">2</td>
<td class="org-left">4,6</td>
<td class="org-left">1,3,5</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">3</td>
<td class="org-left">2,6</td>
<td class="org-left">5</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-left">2,8</td>
<td class="org-left">1,5,7</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">5</td>
<td class="org-left">2,4,6,8</td>
<td class="org-left">1,3,7,9</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">6</td>
<td class="org-left">2,8</td>
<td class="org-left">3,5,9</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">7</td>
<td class="org-left">4,8</td>
<td class="org-left">5</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">8</td>
<td class="org-left">4,6</td>
<td class="org-left">5,7,9</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-right">9</td>
<td class="org-left">6,8</td>
<td class="org-left">5</td>
</tr>
</tbody>
</table>

<p>
The string rbb is accepted by this NFA.
</p>

<p>
Formal NFA
</p>
<ul class="org-ul">
<li>A finite set of states, typically Q.</li>
<li>An input alphabet, typically Σ.</li>
<li>A transition function, typically δ.</li>
<li>A start state in Q, typically q<sub>0</sub>.</li>
<li>A set of final states F &sub; Q.</li>
</ul>

<p>
Transition Function of an NFA
</p>
<ul class="org-ul">
<li>δ(q, ε) is a set of states.</li>
<li>Extend to strings as follows:
<ul class="org-ul">
<li>Basis: δ(q, ε) = {q}</li>
<li>Induction: δ(q, wa) = the union over all states p in δ(q, w) of
δ(p, a)</li>
</ul></li>
</ul>

<p>
Language of an NFA
</p>
<ul class="org-ul">
<li>A string w is accepted by an NFA if δ(q<sub>0</sub>, w) contains at least one
final state.</li>
<li>The language of the NFA is the set of strings it accepts.</li>
</ul>

<p>
Example: Language of an NFA
</p>
<ul class="org-ul">
<li>For our <a href="#org5f94457">chessboard</a> NFA, we saw that rbb is accepted.</li>
<li>If the input consists of only b&rsquo;s, the set of accessible states
alternates between {5} and {1,3,7,9}, so only even-length, nonempty
strings of b&rsquo;s are accepted.</li>
<li>What about strings with at least one r?
<ul class="org-ul">
<li>The nonempty strings containing even number of b&rsquo;s and not ending
with r are accepted.</li>
</ul></li>
</ul>

<p>
Equivalence of DFAs, NFAs
</p>
<ul class="org-ul">
<li>A DFA can be turned into an NFA that accepts the same language.</li>
<li>If δ<sub>D</sub>(q, a) = p, let the NFA have δ<sub>N</sub>(q, a) = {p}.</li>
<li>Then the NFA is always in a set containing exactly one state&#x2014;the
state the DFA is in after reading the same input.</li>
</ul>


<ul class="org-ul">
<li>Surprisingly, for any NFA there is a DFA that accepts the same
languages.</li>
<li>Proof is the <i>subset construction</i>.</li>
<li>The number of states of the DFA can be exponential in the number of
states of the NFA.</li>
<li>Thus, NFAs accept exactly the regular languages.</li>
</ul>

<p>
Subset Construction
</p>
<ul class="org-ul">
<li>Given an NFA with states Q, inputs Σ, transition function δ<sub>N</sub>,
start state q<sub>0</sub>, and final states F, construct equivalent DFA with:
<ul class="org-ul">
<li>States 2<sup>Q</sup> (Set of subsets of Q).</li>
<li>Inputs Σ.</li>
<li>Start state {q<sub>0</sub>}.</li>
<li>Final states = all those with a member of F.</li>
<li>The transition function δ<sub>D</sub> is defined by:
<ul class="org-ul">
<li>δ<sub>D</sub>({q<sub>1</sub>, &#x2026;, q<sub>k</sub>}, a) is the union over all i = 1, &#x2026;, k of
δ<sub>N</sub>(q<sub>i</sub>, a).</li>
</ul></li>
<li>Example: We&rsquo;ll construct the DFA equivalent of our &ldquo;chessboard&rdquo;
NFA.</li>
</ul></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">r</th>
<th scope="col" class="org-left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-left">{1}</td>
<td class="org-left">{2,4}</td>
<td class="org-left">{5}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{2,4}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{1,3,5,7}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{5}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{1,3,7,9}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{1,3,5,7,9}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{1,3,5,7}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{1,3,5,7,9}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{1,3,7,9}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{5}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{1,3,5,7,9}</td>
<td class="org-left">{2,4,6,8}</td>
<td class="org-left">{1,3,5,7,9}</td>
</tr>
</tbody>
</table>

<p>
Proof of Equivalence: Subset Construction
</p>
<ul class="org-ul">
<li>The proof is almost a pun.</li>
<li>Show by induction on |w| that
<ul class="org-ul">
<li>δ<sub>N</sub>(q<sub>0</sub>, w) = δ<sub>D</sub>({q<sub>0</sub>}, w)</li>
</ul></li>
<li>Basis: w = ε: δ<sub>N</sub>(q<sub>0</sub>, ε) = δ<sub>D</sub>({q<sub>0</sub>}, ε) = {q<sub>0</sub>}.</li>
<li>Induction:
<ul class="org-ul">
<li>Assume IH for strings shorter than w.</li>
<li>Let w = xa, IH holds for x.</li>
<li>Let δ<sub>N</sub>(q<sub>0</sub>, x) = δ<sub>D</sub>({q<sub>0</sub>}, x) = S.</li>
<li>Let T = the union over all states p in S of δ<sub>N</sub>(p, a).</li>
<li>Then δ<sub>N</sub>(q<sub>0</sub>, w) = δ<sub>D</sub>({q<sub>0</sub>}, w) = T.</li>
</ul></li>
</ul>

<p>
NFAs With ε-Transitions
</p>
<ul class="org-ul">
<li>We can allow state-to-state transitions on ε input.</li>
<li>These transitions are done spontaneously, without looking at the
input string.</li>
<li>A convenience at times, but still only regular languages are
accepted.</li>
</ul>


<div class="figure">
<p><img src="epsilon-nfa.png" alt="epsilon-nfa.png" width="500px" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
<th scope="col" class="org-left">ε</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-left">A</td>
<td class="org-left">{E}</td>
<td class="org-left">{B}</td>
<td class="org-left">&empty;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">B</td>
<td class="org-left">&empty;</td>
<td class="org-left">{C}</td>
<td class="org-left">{D}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">C</td>
<td class="org-left">&empty;</td>
<td class="org-left">{D}</td>
<td class="org-left">&empty;</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">D</td>
<td class="org-left">&empty;</td>
<td class="org-left">&empty;</td>
<td class="org-left">&empty;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">E</td>
<td class="org-left">{F}</td>
<td class="org-left">&empty;</td>
<td class="org-left">{B,C}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">F</td>
<td class="org-left">{D}</td>
<td class="org-left">&empty;</td>
<td class="org-left">&empty;</td>
</tr>
</tbody>
</table>

<p>
Closure of States
</p>
<ul class="org-ul">
<li>CL(q) = set of states you can reach from state q following only
arcs labeled ε.</li>
<li>Example: CL(A) = {A}, CL(E) = {B,C,D,E}.</li>
<li>Closure of a set of states = union of the closure of each state.</li>
</ul>

<p>
Extended Delta
\(\DeclareMathOperator{\cl}{CL}\)
</p>
<ul class="org-ul">
<li>Intuition: \(\hat\delta(q, w)\) is the set of states you can reach
from q following a path labeled w.</li>
<li>Basis: \(\hat\delta(q, \epsilon) = \cl(q)\)</li>
<li>Induction: \(\hat\delta(q, wa) = \bigcup_{p \in \hat\delta(q, w)}
   \cl(\delta(p, a))\)</li>
</ul>

<p>
Example: Extended Delta
</p>
<ul class="org-ul">
<li>\(\hat\delta(A, \epsilon) = \cl(A) = \{A\}\)</li>
<li>\(\hat\delta(A, 0) = \cl(\delta(A, 0)) = \cl(\{E\}) = \{B,C,D,E\}\)</li>
<li>\(\hat\delta(A, 01) = \bigcup_{p \in \{B,C,D,E\}} \cl(\delta(p, 1))
   = \{C,D\}\)</li>
</ul>

<p>
<i>Language</i> of an ε-NFA is the set of strings w such that
\(\hat\delta(q_0, w)\) contains a final state.
</p>

<p>
Equivalence of NFA and ε-NFA
\(\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}\)
</p>
<ul class="org-ul">
<li>Every NFA is an ε-NFA.
<ul class="org-ul">
<li>It just has no transitions on ε.</li>
</ul></li>
<li>Converse requires us to take an ε-NFA and construct an NFA that
accepts the same language.</li>
<li>We do so by combining ε-transitions with the next transition on a
real input.</li>
<li>Start with an ε-NFA with states Q, inputs Σ, start state q<sub>0</sub>, final
states F, and transition function δ<sub>E</sub>.</li>
<li>Construct an &ldquo;ordinary&rdquo; NFA with states Q, inputs Σ, start state
q<sub>0</sub>, final states \(F'\), and transition function δ<sub>N</sub>.</li>
<li>Compute \(\delta_N(q, a)\) as follows:
<ul class="org-ul">
<li>\(\delta_N(q, a) = \bigcup_{p \in \cl(q)} \delta_E(p, a)\)</li>
</ul></li>
<li>\(F' = \{q \mid \cl(q) \cap F \neq \varnothing\}\)</li>
<li>Prove by induction on \(\abs{w}\) that
<ul class="org-ul">
<li>\(\cl(\hat\delta_N(q_0, w)) = \hat\delta_E(q_0, w)\).</li>
</ul></li>
<li>Thus, the ε-NFA accepts w iff the &ldquo;ordinary&rdquo; NFA does.</li>
</ul>

<p>
Example: ε-NFA to NFA
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-left">A</td>
<td class="org-left">{E}</td>
<td class="org-left">{B}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">B</td>
<td class="org-left">&empty;</td>
<td class="org-left">{C}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">C</td>
<td class="org-left">&empty;</td>
<td class="org-left">{D}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">D</td>
<td class="org-left">&empty;</td>
<td class="org-left">&empty;</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">E</td>
<td class="org-left">{F}</td>
<td class="org-left">{C,D}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">F</td>
<td class="org-left">{D}</td>
<td class="org-left">&empty;</td>
</tr>
</tbody>
</table>

<p>
Summary
</p>
<ul class="org-ul">
<li>DFAs, NFAs, and ε-NFAs all accept exactly the same set of
languages: the regular languages.</li>
<li>The NFA types are easier to design and may have exponentially fewer
states than a DFA.</li>
<li>But only a DFA can be implemented! (quantum computer for NFAs?)</li>
</ul>
</div>
</div>

<div id="outline-container-org5498bfb" class="outline-3">
<h3 id="finite-automata-homework"><a id="org5498bfb"></a><span class="section-number-3">1.5</span> <span class="done DONE">DONE</span> Finite Automata Homework</h3>
<div class="outline-text-3" id="text-finite-automata-homework">
<p>
<b>Question 1-2</b>
</p>


<div class="figure">
<p><img src="w1hwq1-2.png" alt="w1hwq1-2.png" width="400px" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">native implementation</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">N</span> (k)
  (<span class="org-keyword">cond</span> ((&lt; k 2) 0)
        ((= k 2) 2)
        (t (+ (N (- k 2)) (* 2 (N (- k 3)))))))
</pre>
</div>

<p>
<b>Question 3</b>
</p>


<div class="figure">
<p><img src="w1hwq3.png" alt="w1hwq3.png" width="500px" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-left">{A}</td>
<td class="org-left">{A}</td>
<td class="org-left">{B}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{B}</td>
<td class="org-left">{A,C}</td>
<td class="org-left">&empty;</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{A,C}</td>
<td class="org-left">{A}</td>
<td class="org-left">{A,B}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{A,B}</td>
<td class="org-left">{A,C}</td>
<td class="org-left">{B}</td>
</tr>
</tbody>
</table>

<p>
<b>Question 4</b>
</p>


<div class="figure">
<p><img src="w1hwq4.png" alt="w1hwq4.png" width="500px" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">→</td>
<td class="org-left">{A}</td>
<td class="org-left">{A,B}</td>
<td class="org-left">{C}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{A,B}</td>
<td class="org-left">{A,B}</td>
<td class="org-left">{C,D}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{C}</td>
<td class="org-left">{B,D}</td>
<td class="org-left">{D}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{C,D}</td>
<td class="org-left">{A,B,D}</td>
<td class="org-left">{D}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{B,D}</td>
<td class="org-left">{A}</td>
<td class="org-left">{C,D}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{D}</td>
<td class="org-left">{A}</td>
<td class="org-left">{D}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">{A,B,D}</td>
<td class="org-left">{A,B}</td>
<td class="org-left">{C,D}</td>
</tr>
</tbody>
</table>

<p>
<b>Question 5</b>
</p>


<div class="figure">
<p><img src="w1hwq5.png" alt="w1hwq5.png" width="720px" />
</p>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">0</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">→, *</td>
<td class="org-left">{A}</td>
<td class="org-left">{E,L}</td>
<td class="org-left">{F}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{E,L}</td>
<td class="org-left">{E,L}</td>
<td class="org-left">{F}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{F}</td>
<td class="org-left">{E,L}</td>
<td class="org-left">{F}</td>
</tr>
</tbody>
</table>

<p>
The above table is my original interpretation of construction from the
lecture video.  Judged by the given choices, the following table is
what the question wants.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">0</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">→, *</td>
<td class="org-left">{A,B,C,D,H,I,J,K,M,N}</td>
<td class="org-left">{B,C,D,E,G,H,I,J,K,L,M,N}</td>
<td class="org-left">{B,C,D,F,G,H,I,J,K,M,N}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{B,C,D,E,G,H,I,J,K,L,M,N}</td>
<td class="org-left">{B,C,D,E,G,H,I,J,K,L,M,N}</td>
<td class="org-left">{B,C,D,F,G,H,I,J,K,M,N}</td>
</tr>

<tr>
<td class="org-left">*</td>
<td class="org-left">{B,C,D,F,G,H,I,J,K,M,N}</td>
<td class="org-left">{B,C,D,E,G,H,I,J,K,L,M,N}</td>
<td class="org-left">{B,C,D,F,G,H,I,J,K,M,N}</td>
</tr>
</tbody>
</table>

<p>
<b>Question 6</b>
</p>


<div class="figure">
<p><img src="w1hwq6.png" alt="w1hwq6.png" width="500px" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1149025" class="outline-3">
<h3 id="challenge-problem-1"><a id="org1149025"></a><span class="section-number-3">1.6</span> <span class="done DONE">DONE</span> Challenge Problem 1</h3>
<div class="outline-text-3" id="text-challenge-problem-1">
<p>
Let L be the language with alphabet {0, 1, 2} consisting of strings
that do not have any three consecutive 0s, any three consecutive 1s,
or any three consecutive 2s.  Prove that L is a regular language
(hint: design automata or regular expressions for some simpler
languages and then use closure properties of regular languages to get
L).  Harder is to design a DFA A for which the language is L itself,
but we encourage you try to design one as a second part of this
exercise.
</p>

<p>
To prove \(L\) is a regular language, we just need to construct a DFA
and prove the language of this DFA is equivalent to \(L\).  The following
DFA is constructed for this purpose.
</p>


<div class="figure">
<p><img src="cp1.png" alt="cp1.png" width="600px" />
</p>
</div>

<p>
Inductive Hypotheses:
</p>
<ol class="org-ol">
<li>If \(\hat\delta(A, w) = A\), then \(w \in L\) and \(w = \epsilon\).</li>
<li>If \(\hat\delta(A, w) = B\), then \(w \in L\), \(w\) ends in \(0\), and
the second last symbol in \(w\), if it has one, is not \(0\).</li>
<li>If \(\hat\delta(A, w) = C\), then \(w \in L\), \(w\) ends in \(1\), and
the second last symbol in \(w\), if it has one, is not \(1\).</li>
<li>If \(\hat\delta(A, w) = D\), then \(w \in L\), \(w\) ends in \(2\), and
the second last symbol in \(w\), if it has one, is not \(2\).</li>
<li>If \(\hat\delta(A, w) = E\), then \(w \in L\) and \(w\) ends in \(00\).</li>
<li>If \(\hat\delta(A, w) = F\), then \(w \in L\) and \(w\) ends in \(11\).</li>
<li>If \(\hat\delta(A, w) = G\), then \(w \in L\) and \(w\) ends in \(22\).</li>
</ol>

<p>
Basis: \(\abs{w} = 0\), which means \(w = \epsilon\).  IH1 clearly holds
since \(\hat\delta(A, \epsilon) = A\) and \(\epsilon \in L\).  All other
IHs hold <i>vacuously</i>.
</p>

<p>
Induction: \(\abs{w} > 0\)
</p>
<ul class="org-ul">
<li>Let \(w = xa\) and assume IHs hold for \(x\).</li>
<li>\(\hat\delta(A, w) = \delta(\hat\delta(A, x), a) \neq A\), since
\(\delta(q, a) \neq A\) for all \(q \in \Sigma\).  And thus IH1 holds
<i>vacuously</i>.</li>
<li><p>
If \(\hat\delta(A, w) = \delta(\hat\delta(A, x), a) = B\), then
\(\hat\delta(A, x) \in \{A,C,D,F,G\}\) and \(a = 0\).
</p>
<ul class="org-ul">
<li>If \(\hat\delta(A, x) = A\), then \(x = \epsilon\).  Therefore, \(w
     = \epsilon 0 = 0\) and \(w \in L\).</li>
<li>If \(\hat\delta(A, x) = C\), then \(x \in L\), and \(x\) ends in \(1\).
Let \(x = y1\), then \(w = y10\).  It follows that \(w \in L\), \(w\)
ends in \(0\), and the second last symbol in \(w\), if it has one, is
not \(0\).</li>
<li>Do the same thing for \(\hat\delta(A, x) = D\) as above.</li>
<li>If \(\hat\delta(A, x) = F\), then \(x \in L\), and \(x\) ends in \(11\).
Let \(x = y11\), then \(w = y110\).  It follows that \(w \in L\), \(w\)
ends in \(0\), and the second last symbol in \(w\), if it has one, is
not \(0\).</li>
<li>Do the same thing for \(\hat\delta(A, x) = G\) as above.</li>
</ul>
<p>
Thus, IH2 holds.
</p></li>
<li>Do the same thing for IH3 through IH7.</li>
<li>All our IHs hold for \(w\).</li>
</ul>

<p>
Our IHs hold for all \(w\), which is the same thing to say that every \(w\)
accepted by this DFA is in the language \(L\).
</p>

<p>
To prove the other direction, we take the contrapositive.
</p>

<p>
If \(w\) is not accepted by this DFA, then \(\hat\delta(A, w) = H\) and
\(\abs{w} > 2\).  Let \(w = xabc\).
</p>
<ul class="org-ul">
<li>\(\hat\delta(A, w) = \delta(\hat\delta(A, xab), c) = H\)</li>
<li>\(\hat\delta(A, xab) \in \{E,F,G\}\)
<ul class="org-ul">
<li>If \(\hat\delta(A, xab) = E\), then \(c = a = b = 0\).  Thus, \(w =
     x000\) and \(w \notin L\).</li>
<li>Do the same thing for \(F\) and \(G\).</li>
</ul></li>
<li>Therefore, \(w \notin L\).</li>
</ul>

<p>
Hence, every string in the language \(L\) is
accepted by this DFA.
</p>
</div>
</div>

<div id="outline-container-orgc2f6769" class="outline-3">
<h3 id="orgc2f6769"><span class="section-number-3">1.7</span> <span class="done DONE">DONE</span> Problem Session 1</h3>
<div class="outline-text-3" id="text-1-7">
</div>
</div>
</div>


<div id="outline-container-orga05905d" class="outline-2">
<h2 id="regular-expressions-and-properties-of-regular-languages"><a id="orga05905d"></a><span class="section-number-2">2</span> <span class="todo IN_PROGRESS">IN-PROGRESS</span> <a href="https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+SelfPaced/courseware/b9162be11c7b4c61a573a50e3aba5738/8c5876c1e4bb46af8fbf4a51ecfccbbc/">Regular Expressions and Properties of Regular Languages</a></h2>
<div class="outline-text-2" id="text-regular-expressions-and-properties-of-regular-languages">
</div>
<div id="outline-container-org15f6675" class="outline-3">
<h3 id="regular-expressions"><a id="org15f6675"></a><span class="section-number-3">2.1</span> <span class="done DONE">DONE</span> Regular expressions</h3>
<div class="outline-text-3" id="text-regular-expressions">
<p>
REs: Introduction
</p>
<ul class="org-ul">
<li><i>Regular expressions</i> describe languages by an algebra.</li>
<li>They describe exactly the regular languages.</li>
<li>If E is a regular expression, then L(E) is the language it defines.</li>
<li>We&rsquo;ll describe REs and their languages recursively.</li>
</ul>

<p>
Operations on Languages
</p>
<ul class="org-ul">
<li>REs use three operations: union, concatenation, and Kleene star.</li>
<li>The union of languages is the usual thing, since languages are
sets.
<ul class="org-ul">
<li>Example: \(\{01, 111, 10\} \cup \{00, 01\} = \{01, 111, 10, 00\}\).</li>
</ul></li>
<li>The <i>concatenation</i> of languages L and M is denoted LM.  It
contains every string wx such that w is in L and x is in M.
<ul class="org-ul">
<li>Example: \(\{01, 111, 10\}\{00, 01\} = \{0100, 0101, 11100, 11101,
     1000, 1001\}\)</li>
</ul></li>
<li>If L is a language, then L<sup>*</sup>, the <i>Kleene star</i>, or just star, is
the set of strings formed by concatenating zero or more strings
from L, in any order.
<ul class="org-ul">
<li>\(L^* = \{\epsilon\} \cup L \cup LL \cup LLL \cup \dotsb\)</li>
<li>Example: \(\{0, 10\}^* = \{\epsilon, 0, 10, 00, 010, 100, 1010,
     \dotsc\}\)</li>
</ul></li>
</ul>

<p>
REs: Definition
</p>
<ul class="org-ul">
<li>Basis 1: If \(a\) is any symbol, then \(\mathbf{a}\) is a RE, and
\(L(\mathbf{a}) = \{a\}\).
<ul class="org-ul">
<li>Note: \(\{a\}\) is the language containing one string, and that string
is of length 1.</li>
</ul></li>
<li>Basis 2: \(\epsilon\) is a RE, and \(L(\epsilon) = \{\epsilon\}\).</li>
<li>Basis 3: \(\varnothing\) is a RE, and \(L(\varnothing) = \varnothing\).</li>
<li>Induction 1: If \(E_1\) and \(E_2\) are regular expressions, then
\(E_1 + E_2\) is a regular expression, and \(L(E_1+E_2) = L(E_1) \cup
   L(E_2)\).</li>
<li>Induction 2: If \(E_1\) and \(E_2\) are regular expressions, then \(E_1
   E_2\) is a regular expression, and \(L(E_1 E_2) = L(E_1) L(E_2)\)</li>
<li>Induction 3: If \(E\) is a RE, then \(E^*\) is a RE, and \(L(E^*) =
   L(E)^*\).</li>
</ul>

<p>
Precedence of Operators
</p>
<ul class="org-ul">
<li>Parentheses may be used wherever needed to influence the grouping
of operators.</li>
<li>Order of precedence is \(*\) (highest), then concatenation, then \(+\)
(lowest).</li>
</ul>

<p>
Examples: REs
</p>
<ul class="org-ul">
<li>\(L(\mathbf{01}) = \{01\}\).</li>
<li>\(L(\mathbf{01}+\mathbf{0}) = \{01, 0\}\).</li>
<li>\(L(\mathbf{0}(\mathbf{1}+\mathbf{0})) = \{01, 00\}\).
<ul class="org-ul">
<li>Note order of precedence of operators.</li>
</ul></li>
<li>\(L(\mathbf{0}^*) = \{\epsilon, 0, 00, 000, \dotsc\}\).</li>
<li>\(L((\mathbf{0}+\mathbf{10})^*(\epsilon+\mathbf{1})) =\) all strings
of 0s and 1s without two consecutive 1s.</li>
</ul>

<p>
Equivalence of REs and Finite Automata
</p>
<ul class="org-ul">
<li>We need to show that for every RE, there is a finite automaton that
accepts the same language.
<ul class="org-ul">
<li>Pick the most powerful automaton type: the ε-NFA.</li>
</ul></li>
<li>And we need to show that for every finite automaton, there is a RE
defining its language.
<ul class="org-ul">
<li>Pick the most restrictive type: the DFA.</li>
</ul></li>
</ul>

<p>
Converting a RE to an ε-NFA
</p>
<ul class="org-ul">
<li>Proof is an induction on the number of operator (+, concatenation, *)
in the RE.</li>
<li>We always construct an automaton of a special form.</li>
</ul>

<p>
Form of ε-NFAs Constructed
</p>
<ul class="org-ul">
<li>&ldquo;Start&rdquo; state: Only state with external predecessors</li>
<li>&ldquo;Final&rdquo; state: Only state with external successors</li>
</ul>

<p>
RE to ε-NFA: Basis
</p>
<ul class="org-ul">
<li><p>
Symbol \(\mathbf{a}\):
</p>

<div class="figure">
<p><img src="a.png" alt="a.png" width="200px" />
</p>
</div></li>
<li><p>
\(\epsilon\):
</p>

<div class="figure">
<p><img src="epsilon.png" alt="epsilon.png" width="200px" />
</p>
</div></li>

<li><p>
\(\varnothing\):
</p>

<div class="figure">
<p><img src="varnothing.png" alt="varnothing.png" width="200px" />
</p>
</div></li>
</ul>

<p>
RE to ε-NFA: Induction 1&#x2014;Union
</p>

<div class="figure">
<p><img src="re-union.png" alt="re-union.png" width="440px" />
</p>
<p><span class="figure-number">Figure 16: </span>For \(E_1 + E_2\)</p>
</div>

<p>
RE to ε-NFA: Induction 2&#x2014;Concatenation
</p>

<div class="figure">
<p><img src="re-concat.png" alt="re-concat.png" width="600px" />
</p>
<p><span class="figure-number">Figure 17: </span>For \(E_1 E_2\)</p>
</div>

<p>
RE to ε-NFA: Induction 3&#x2014;Closure
</p>

<div class="figure">
<p><img src="re-closure.png" alt="re-closure.png" width="575px" />
</p>
<p><span class="figure-number">Figure 18: </span>For \(E^*\)</p>
</div>

<p>
DFA to RE
</p>
<ul class="org-ul">
<li>A strange sort of induction</li>
<li>States of the DFA are named 1, 2, &#x2026;, n.</li>
<li>Induction is on k, the maximum state number we are allowed to
traverse along a path.</li>
</ul>

<p>
k-Paths
</p>
<ul class="org-ul">
<li>A k-path is a path through the graph of the DFA that goes through
no state numbered higher than k.</li>
<li>Endpoints are not restricted; they can be any state.</li>
<li>n-paths are unrestricted.</li>
<li>RE is the union of REs for the n-paths from the start state to each
final state.</li>
</ul>

<p>
Basis: \(k = 0\); only arcs or a node by itself.
</p>

<p>
Induction: construct REs for paths allowed to pass through state \(k\)
from paths allowed only up to \(k-1\).
</p>

<p>
k-Path Induction
</p>
<ul class="org-ul">
<li>Let \(R_{ij}^k\) be the regular expression for the set of labels of
k-paths from state \(i\) to state \(j\).</li>
<li>Basis: \(k = 0\). \(R_{ij}^0 =\) sum of labels of arc from i to j.
<ul class="org-ul">
<li>\(\varnothing\) if no such arc.</li>
<li>But add \(\epsilon\) if \(i = j\).</li>
</ul></li>
<li>Induction:
<ul class="org-ul">
<li>A k-path from \(i\) to \(j\) either:
<ol class="org-ol">
<li>Never goes through state \(k\), or</li>
<li>Goes through \(k\) one or more times.</li>
</ol></li>
<li>\(R_{ij}^k = R_{ij}^{k-1} + R_{ik}^{k-1}(R_{kk}^{k-1})^*R_{kj}^{k-1}\).</li>
</ul></li>
<li>Final Step
<ul class="org-ul">
<li>The RE with the same language as the DFA is the sum (union) of
\(R_{ij}^n\), where:
<ol class="org-ol">
<li>\(n\) is the number of states; i.e., paths are unconstrained.</li>
<li>\(i\) is the start state.</li>
<li>\(j\) is one of the final states.</li>
</ol></li>
</ul></li>
</ul>

<p>
Summary
</p>
<ul class="org-ul">
<li>Each of the three types of automata (DFA, NFA, ε-NFA) we discussed,
and regular expressions as well, define exactly the same set of
languages: the regular languages.</li>
</ul>


<div class="figure">
<p><img src="re-summary.png" alt="re-summary.png" width="270px" />
</p>
</div>

<p>
Algebraic Laws for REs
</p>
<ul class="org-ul">
<li>Union and concatenation behave sort of like addition and
multiplication.
<ul class="org-ul">
<li>+ is commutative and associative; concatenation is associative.</li>
<li>Concatenation distributes over +.</li>
<li>Exception: Concatenation is not commutative.</li>
</ul></li>
</ul>

<p>
Identities and Annihilators
</p>
<ul class="org-ul">
<li>\(\varnothing\) is the identity for \(+\).</li>
<li>\(\epsilon\) is the identity for concatenation.</li>
<li>\(\varnothing\) is the annihilator for concatenation.
<ul class="org-ul">
<li>\(\varnothing R = R \varnothing = \varnothing\).</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge2a30c4" class="outline-3">
<h3 id="regular-expressions-in-the-real-world"><a id="orge2a30c4"></a><span class="section-number-3">2.2</span> <span class="done DONE">DONE</span> Regular expressions in the real world</h3>
<div class="outline-text-3" id="text-regular-expressions-in-the-real-world">
<p>
Applications of Regular Expressions
</p>
<ul class="org-ul">
<li>Unix REs</li>
<li>Text processing</li>
<li>Lexical analysis</li>
</ul>

<p>
Some Applications
</p>
<ul class="org-ul">
<li>REs appear in many systems, often private software that needs a
simple language to describe sequences of events.</li>
<li>We&rsquo;ll use Junglee as an example, then talk about text processing
and lexical analysis.</li>
</ul>

<p>
RE-Based Software Architecture
</p>
<ul class="org-ul">
<li>Junglee used a common form of architecture:
<ul class="org-ul">
<li>Use REs plus actions (arbitrary code) as your input language.</li>
<li>Compile into a DFA or simulated NFA.</li>
<li>Each accepting state is associated with an action, which is
executed when that state is entered.</li>
</ul></li>
</ul>

<p>
UNIX Regular Expressions
</p>
<ul class="org-ul">
<li>UNIX, from the beginning, used regular expressions in many places,
including the &ldquo;grep&rdquo; command.
<ul class="org-ul">
<li>Grep = &ldquo;Global (search for a) Regular Expression and Print.&rdquo;
<code>g/re/p</code></li>
</ul></li>
<li>Most UNIX commands use an extended RE notation that still defines
only regular languages.</li>
</ul>

<p>
UNIX RE Notation
</p>
<ul class="org-ul">
<li>\([a_1 a_2 \dotsm a_n]\) is shorthand for \(a_1 + a_2 + \dotsb + a_n\).</li>
<li><i>Ranges</i> indicated by first-dash-last and brackets.
<ul class="org-ul">
<li>Order is ASCII.</li>
<li>Examples: <code>[a-z]</code> = &ldquo;any lowercase letter,&rdquo; <code>[a-zA-Z]</code> = &ldquo;any
letter.&rdquo;</li>
</ul></li>
<li>Dot = &ldquo;any character.&rdquo;</li>
<li><code>|</code> is used for union instead of <code>+</code>.</li>
<li>But <code>+</code> has a meaning: &ldquo;one or more of.&rdquo;
<ul class="org-ul">
<li><code>E+</code> = <code>EE*</code>.</li>
<li>Example: <code>[a-z]+</code> = &ldquo;one or more lowercase letters.&rdquo;</li>
</ul></li>
<li><code>?</code> = &ldquo;zero or one of.&rdquo;
<ul class="org-ul">
<li><code>E?</code> = <code>E + ε</code>.</li>
<li>Example: <code>[ab]?</code> = <code>a+b+ε</code> = &ldquo;an optional <i>a</i> or <i>b</i>.&rdquo;</li>
</ul></li>
</ul>

<p>
Example: Text Processing
</p>
<ul class="org-ul">
<li>Remember our DFA for recognizing strings that end in &ldquo;ing&rdquo;?</li>
<li>It was rather tricking.</li>
<li>But the RE for such strings is easy:
<code>.*ing</code> where the dot is the UNIX &ldquo;any.&rdquo;</li>
<li>Even an NFA is easy.</li>
</ul>


<div class="figure">
<p><img src="nfa-ing.png" alt="nfa-ing.png" width="500px" />
</p>
<p><span class="figure-number">Figure 20: </span>NFA for strings ending in &ldquo;ing&rdquo;</p>
</div>

<p>
Lexical Analysis
</p>
<ul class="org-ul">
<li>The first thing a compiler does is break a program into <i>tokens</i> (=
substrings) that together represent a unit.
<ul class="org-ul">
<li>Examples: identifiers, reserved words like <code>if</code>, meaningful
single characters like <code>;</code> or <code>+</code>, multicharacter operators like
<code>&lt;=</code>.</li>
</ul></li>
<li>Using a tool like Lex or Flex, one can write a regular expression
for each different kind of token.</li>
<li>Example: in UNIX notation, identifiers are something like
<code>[A-Za-z][A-Za-z0-9_]*</code>.</li>
<li>Each RE has an associated action.
<ul class="org-ul">
<li>Example: return a code for the token found.</li>
</ul></li>
</ul>

<p>
Tricks for Combining Tokens
</p>
<ul class="org-ul">
<li>There are some ambiguities that need to be resolved as we convert
REs to a DFA.</li>
<li>Examples:
<ol class="org-ol">
<li><code>if</code> looks like an identifier, but it is a reserved word.</li>
<li><code>&lt;</code> might be a comparison operator, but if followed by <code>=</code>, then
the token is <code>&lt;=</code>.</li>
</ol></li>
<li>Convert the RE for each token to an ε-NFA.
<ul class="org-ul">
<li>Each has its own final state.</li>
</ul></li>
<li>Combine these all by introducing a new start state with
ε-transitions to the start states of each ε-NFA.</li>
<li>Then convert to a DFA.</li>
<li>If a DFA state has several final states among its members, give
them priority.</li>
<li>Example: Give all reserved words priority over identifiers, so if
the DFA arrives at a state that contains final states for the <code>if</code>
ε-NFA as well as for the identifier ε-NFA, it declares <code>if</code>, not
identifier.</li>
<li>It&rsquo;s a bit more complicated, because the DFA has to have an
additional power.</li>
<li>It must be able to read an input symbol and then, when it accepts,
put that symbol back on the input to be read later.</li>
</ul>

<p>
Example: Put-Back
</p>
<ul class="org-ul">
<li>Suppose <code>&lt;</code> is the first input symbol.</li>
<li>Read the next input symbol.
<ul class="org-ul">
<li>If it is <code>=</code>, accept and declare the token is <code>&lt;=</code>.</li>
<li>If it is anything else, put it back and declare the token is <code>&lt;</code>.</li>
</ul></li>
<li>Suppose <code>if</code> has been read from the input.</li>
<li>Read the next input symbol.
<ul class="org-ul">
<li>If it is a letter or digit, continue processing.
<ul class="org-ul">
<li>You did not have reserved word <code>if</code>; you are working on an
identifier.</li>
</ul></li>
<li>Otherwise, put it back and declare the token is <code>if</code>.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org36d4cb6" class="outline-3">
<h3 id="regular-expression-homework"><a id="org36d4cb6"></a><span class="section-number-3">2.3</span> <span class="done DONE">DONE</span> Regular-Expression Homework</h3>
<div class="outline-text-3" id="text-regular-expression-homework">
</div>
</div>

<div id="outline-container-org73bfe48" class="outline-3">
<h3 id="decision-algorithms-for-regular-languages"><a id="org73bfe48"></a><span class="section-number-3">2.4</span> <span class="todo TODO">TODO</span> Decision algorithms for regular languages</h3>
<div class="outline-text-3" id="text-decision-algorithms-for-regular-languages">
</div>
</div>

<div id="outline-container-org66b2b49" class="outline-3">
<h3 id="closure-properties-of-regular-languages"><a id="org66b2b49"></a><span class="section-number-3">2.5</span> <span class="todo TODO">TODO</span> Closure properties of regular languages</h3>
<div class="outline-text-3" id="text-closure-properties-of-regular-languages">
</div>
</div>

<div id="outline-container-org407f6f3" class="outline-3">
<h3 id="properties-of-regular-languages-homework"><a id="org407f6f3"></a><span class="section-number-3">2.6</span> <span class="todo TODO">TODO</span> Properties-of-Regular-Languages Homework</h3>
<div class="outline-text-3" id="text-properties-of-regular-languages-homework">
</div>
</div>

<div id="outline-container-orgee510b8" class="outline-3">
<h3 id="challenge-problem-2"><a id="orgee510b8"></a><span class="section-number-3">2.7</span> <span class="todo TODO">TODO</span> Challenge Problems 2</h3>
<div class="outline-text-3" id="text-challenge-problem-2">
</div>
</div>

<div id="outline-container-org82fe1c8" class="outline-3">
<h3 id="org82fe1c8"><span class="section-number-3">2.8</span> <span class="todo TODO">TODO</span> Problem Session 2</h3>
<div class="outline-text-3" id="text-2-8">
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Lei Zhao</p>
<p class="date">Created: 2018-01-16 Tue 21:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
