#+STARTUP: content
#+STARTUP: inlineimages
#+STARTUP: hideblocks
#+TODO: TODO IN-PROGRESS DONE
#+PROPERTY: header-args:latex :results raw :headers '("\\usepackage{tikz}") :fit yes :imagemagick yes :iminoptions -density 300 :imoutoptions -flatten

[[https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+SelfPaced/courseware/751b6dfa045849d8bec2fdd55c89a3b9/][Automata Theory]] on Lagunita

* IN-PROGRESS Week 1: [[https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+SelfPaced/courseware/544b7a8df3844f428bc1a5125c594702/ec6439250bb4426ab93c543e140dacb4/][Finite Automata]]
** DONE Course outline and motivation
   CLOSED: [2017-08-26 Sat 11:00]
Automata is ranked second after database for optional courses in a
Stanford survey of grads 5 years out.  3X the score for AI.

  * Regular expressions are used in many systems.
    - UNIX a.*b.
    - DTD describe XML tags with a RE format like
      ~person(name, addr, child*)~.
  * Finite automata model protocols, electronic circuits.
  * Context-free grammars are used to describe the syntax of
    essentially every programming language.
    - Not to forget their important role in describing natural
      languages.
  * And DTD taken as a whole, are really CFGs.
  * When developing solutions to real problems, we often confront the
    limitations of what software can do.
    - /Undecidable/ things - no program whatever can do it.
    - /Intractable/ things - there are programs, but no fast programs.
  * Automata theory gives you the tools.

Other Good Stuff

  * We'll learn how to deal formally with discrete systems.
    - Proofs: You never really prove a program correct, but you need
      to be thinking of why a tricky technique really works.
  * We'll gain experience with abstract models and constructions.
    - Models layered software architectures.

Course Outline

  * Regular Languages and their descriptors:
    - Finite automata, nondeterministic finite automata, regular
      expressions.
    - Algorithms to decide questions about regular languages, e.g., is
      it empty?
    - Closure properties of regular languages.
  * Context-free languages and their descriptors:
    - Context-free grammars, pushdown automata.
    - Decision and closure properties.
  * Recursive and recursively enumerable languages.
    - Turing machines, decidability of problems.
    - The limit of what can be computed.
  * Intractable problems.
    - Problems that (appear to) require exponential time.
    - NP-completeness and beyound.

** DONE Informal introduction to finite automata
   CLOSED: [2017-09-05 Tue 20:43]

What is a Finite Automaton?

  * A formal system.
  * Remembers only a finite amount of information.
  * Information represented by its /state/.
  * State changes in response to /inputs/.
  * Rules that tell how the state changes in response to inputs are
    called /transitions/.


Tennis

  * /Match/ = 3-5 sets.
  * /Set/ = 6 or more games.

Scoring a Game

  * One person serves throughout.
  * To win, you must score at least 4 points.
  * You also must win by at least 2 points.
  * Inputs are s = "server wins point" and o = "opponent wins point."


#+BEGIN_SRC latex :file tennis.png
\usetikzlibrary{positioning,shapes,automata}
\begin{tikzpicture}
  [shorten >=1pt,node distance=1cm and 2.5cm,on grid,auto,
   every state/.style={ellipse,align=center}]
%% \draw[help lines] (0,0) grid (3,2);
\node[state,initial]     (Love)                                                 {Love};
\node[state]             (15-Love)     [above right=of Love]                    {15-Love};
\node[state]             (Love-15)     [below right=of Love]                    {Love-15};
\node[state]             (30-Love)     [above right=of 15-Love]                 {30-Love};
\node[state]             (15-all)      [below right=of 15-Love]                 {15-all};
\node[state]             (Love-30)     [below right=of Love-15]                 {Love-30};
\node[state]             (40-Love)     [above right=of 30-Love]                 {40-Love};
\node[state]             (30-15)       [below right=of 30-Love]                 {30-15};
\node[state]             (15-30)       [below right=of 15-all]                  {15-30};
\node[state]             (Love-40)     [below right=of Love-30]                 {Love-40};
\node[state,accepting]   (Server Wins) [above right=of 40-Love,text width=3em]  {Server Wins};
\node[state]             (40-15)       [below right=of 40-Love]                 {40-15};
\node[state]             (30-all)      [below right=of 30-15]                   {30-all};
\node[state]             (15-40)       [below right=of 15-30]                   {15-40};
\node[state,accepting]   (Opp'nt Wins) [below right=of Love-40,text width=3em]  {Opp'nt Wins};
\node[state]             (40-30)       [below right=of 40-15]                   {40-30};
\node[state]             (30-40)       [below right=of 30-all]                  {30-40};
\node[state]             (deuce)       [below right=of 40-30]                   {deuce};
\node[state]             (Add-in)      [above right=of 40-30]                   {Add-in};
\node[state]             (Add-out)     [below right=of 30-40]                   {Add-out};

\path[->] (Love)       edge               node {s}    (15-Love)
                       edge               node {o}    (Love-15)
          (15-Love)    edge               node {s}    (30-Love)
                       edge               node {o}    (15-all)
          (Love-15)    edge               node {s}    (15-all)
                       edge               node {o}    (Love-30)
          (30-Love)    edge               node {s}    (40-Love)
                       edge               node {o}    (30-15)
          (15-all)     edge               node {s}    (30-15)
                       edge               node {o}    (15-30)
          (Love-30)    edge               node {s}    (15-30)
                       edge               node {o}    (Love-40)
          (40-Love)    edge               node {s}    (Server Wins)
                       edge               node {o}    (40-15)
          (30-15)      edge               node {s}    (40-15)
                       edge               node {o}    (30-all)
          (15-30)      edge               node {s}    (30-all)
                       edge               node {o}    (15-40)
          (Love-40)    edge               node {s}    (15-40)
                       edge               node {o}    (Opp'nt Wins)
          (40-15)      edge               node {s}    (Server Wins)
                       edge               node {o}    (40-30)
          (30-all)     edge               node {s}    (40-30)
                       edge               node {o}    (30-40)
          (15-40)      edge               node {s}    (30-40)
                       edge               node {o}    (Opp'nt Wins)
          (40-30)      edge               node {s}    (Server Wins)
                       edge               node {o}    (deuce)
          (30-40)      edge               node {s}    (deuce)
                       edge               node {o}    (Opp'nt Wins)
          (deuce)      edge [bend left]   node {s}    (Add-in)
                       edge [bend left]   node {o}    (Add-out)
          (Add-in)     edge               node {s}    (Server Wins)
                       edge [bend left]   node {o}    (deuce)
          (Add-out)    edge [bend left]   node {s}    (deuce)
                       edge               node {o}    (Opp'nt Wins);
\end{tikzpicture}
#+END_SRC

#+ATTR_HTML: :width 800px
#+RESULTS:
[[file:tennis.png]]


Acceptance of Inputs

  * Given a sequence of inputs (/input string/), start in the start
    state and follow the transition from each symbol in turn.
  * Input is /accepted/ if you wind up in a final (accepting) state
    after all inputs have been read.

Language of an Automaton

  * The set of strings accepted by an automaton A is the /language/ of A.
  * Denoted L(A).
  * Different sets of final states → different languages.
  * Example: As designed, L(Tennis) = strings that determins the winner.

** IN-PROGRESS Deterministic Finite Automata
   :PROPERTIES:
   :VISIBILITY: children
   :END:

Alphabets

  * An /alphabet/ is any finite set of symbols.
  * Examples:
    ASCII, Unicode,
    {0, 1} (/binary alphabet/),
    {a, b, c}, {s, o},
    set of signals used by a protocol.


Strings

  * A /string/ over an alphabet Σ is a list, each element of
    which is a member of Σ.
    - Strings shown with no commas or quotes, e.g., abc or 01101.
  * Σ^{*} = set of all strings over alphabet Σ.
  * The /length/ of a string is its number of positions.
  * ε stands for the /empty string/ (string of length 0).

Example: Strings

  * {0, 1}^{*} = {ε, 0, 1, 00, 01, 10, 11, 000, 001, ...}
  * Subtlety: 0 as a string, 0 as a symbol look the same.
    - Context determines the type.


Languages

  * A /language/ is a subset of Σ^{*} for some alphabet Σ.
  * Example: The set of string of 0s and 1s with no two consecutive 1s.
  * L = {ε, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000,
    0001, 0010, 0100, 0101, 1000, 1001, 1010, ...}
    Fibonacci sequence hides here.


Deterministic Finite Automata

  * A formalism for defining languages,
    consisting of:
    1. A finite set of /states/ (Q, typically).
    2. An /input alphabet/ (Σ, typically).
    3. A /transition function/ (\delta, typically).
    4. A /start state/ (q_{0}, in Q, typically).
    5. A set of /final states/ (F \subset Q, typically).
       + "Final" and "accepting" are synonyms.


The Transition Function

  * Takes two arguments: a state and an input symbol.
  * \delta(q, a) = the state that the DFA goes to when it is in state
    q and input a is received.
  * Note: always a next state - add a /dead state/ if no transition


Graph Representation of DFAs

  * Nodes = states.
  * Arcs represent transition function.
    - Arc from state p to state q labeled by all those input symbols
      that have transitions from p to q.
  * Arrow labeled "Start" to the start state.
  * Final states indicated by double circles.

#+BEGIN_SRC latex :file ing.png
\usetikzlibrary{positioning,shapes,automata}
\begin{tikzpicture}
  [shorten >=1pt,node distance=3cm,on grid,auto,inner xsep=0pt,
   every state/.style={ellipse,align=center}]
% \draw[help lines] (0,0) grid (3,2);
\node[state,initial]                    (nothing) {nothing};
\node[state,right=of nothing]           (i)       {saw \textit{i}};
\node[state,right=of i]                 (in)      {saw \textit{in}};
\node[state,accepting,right=of in]      (ing)     {saw \textit{ing}};

\path[->] (nothing) edge                       node         {\textit{i}}                    (i)
                    edge [in=150,out=120,loop] node [above] {not \textit{i}}                (nothing)
          (i)       edge                       node         {\textit{n}}                    (in)
                    edge [loop below]          node         {\textit{i}}                    (i)
                    edge [bend right]          node [above] {not \textit{i} or \textit{n}}  (nothing)
          (in)      edge                       node         {\textit{g}}                    (ing)
                    edge [bend right]          node [above] {\textit{i}}                    (i)
                    edge [bend right=90]       node [above] {not \texitit{i} or \textit{g}} (nothing)
          (ing)     edge [bend left]           node         {\textit{i}}                    (i)
                    edge [bend left=90]        node         {not \textit{i}}                (nothing);
\end{tikzpicture}
#+END_SRC

#+ATTR_HTML: :width 600px
#+RESULTS:
[[file:ing.png]]




#+TITLE: Automata Theory
#+AUTHOR: Lei Zhao
#+HTML_HEAD: <link type="text/css" href="../styles/syntax-highlight.css" rel="stylesheet"/>
#+HTML_HEAD: <link type="text/css" href="../styles/layout.css" rel="stylesheet"/>
#+HTML_HEAD: <script type="text/javascript" src="../src/post.js"></script>
# #+INFOJS_OPT: view:info path:../lib/org-info.js
#+OPTIONS: ^:{} \n:t
